# 世代管理パターンの手引き

## 🤔 AIが理解に困る典型的な状況

### 1. どのパターンを選ぶべきか

#### 選択フローチャート
```
世代管理が必要？
├─ NO → 最新状態のみでOK（UPDATE可）
└─ YES → 以下を確認
    │
    ├─ 過去の世代を参照する頻度は？
    │  ├─ 高い → パターン選択へ
    │  └─ 低い → アーカイブテーブル検討
    │
    └─ 未来の世代も扱う？
       ├─ YES → 世代バージョンタグ付けパターン
       └─ NO → 基本パターンから選択
```

### 2. 基本パターンの詳細

#### シングル世代テーブルパターン
```
価格 (R) {
  商品ID
  価格
  適用開始日
  適用終了日
}

// 使用時のSQL
SELECT 価格 
FROM 価格
WHERE 商品ID = :id
  AND :target_date BETWEEN 適用開始日 AND 適用終了日
```

**メリット**
- シンプルな構造
- 過去・現在・未来を統一的に扱える

**デメリット**
- 全クエリにBETWEEN条件必須
- インデックス設計が重要

#### 有効世代ビューパターン
```
// マスタテーブル（全世代）
価格マスタ {
  商品ID
  価格
  適用開始日
  適用終了日
}

// マテリアライズドビュー（現在有効分のみ）
現在価格 {
  商品ID
  価格
}

// 通常はビューを使用
SELECT 価格 FROM 現在価格 WHERE 商品ID = :id
```

**メリット**
- 開発が簡単（通常はビューを見るだけ）
- パフォーマンス良好

**デメリット**
- ビューの更新タイミング設計が必要
- 過去データ参照は別途実装

#### 世代バージョンタグ付けパターン
```
価格バージョン {
  バージョンID
  商品ID
  価格
  作成日時
}

価格タグ {
  タグ名  // 'current', '2024Q1', etc
  バージョンID
}

// 現在価格の取得
SELECT p.* 
FROM 価格バージョン p
JOIN 価格タグ t ON p.バージョンID = t.バージョンID
WHERE t.タグ名 = 'current'
  AND p.商品ID = :id
```

**メリット**
- Git風の柔軟な管理
- 任意時点のスナップショット可能

**デメリット**
- 実装が複雑
- タグ管理の運用ルール必要

### 3. 継承パターンの使い分け

#### パターン選択マトリクス
| パターン | 横断検索 | 属性差異 | テーブル数 |
|---------|---------|---------|-----------|
| シングルテーブル | 多い | 少ない | 1 |
| 具象テーブル | 少ない | 大きい | サブタイプ数 |
| クラステーブル | 中程度 | 大きい | 1+サブタイプ数 |

#### 具体例での判断

**例：社員の雇用形態**

分析：
- 横断検索：全社員リストなど頻繁
- 属性差異：正社員は年俸、パートは時給

判断：
- シングルテーブル継承が適切
- NULL許容で属性差異を吸収

```
社員 {
  社員ID
  氏名
  雇用形態
  年俸     // 正社員のみ
  時給     // パートのみ
  月給     // 契約社員のみ
}
```

## 💡 実装のコツ

### 世代の切り替えタイミング

#### 即時切り替え
```
価格変更 (E) {
  変更ID
  商品ID
  新価格
  変更日時  // = 適用開始日時
}
```

#### 予約切り替え
```
価格変更予約 (E) {
  予約ID
  商品ID
  新価格
  予約日時
  適用予定日時
}

// バッチで適用予定日時に切り替え
```

### 世代の重複・空白対策

#### 重複防止
```sql
-- 制約またはトリガーで実装
CHECK (NOT EXISTS (
  SELECT 1 FROM 価格 p2
  WHERE p2.商品ID = 商品ID
    AND p2.rowid != rowid
    AND 適用開始日 <= p2.適用終了日
    AND 適用終了日 >= p2.適用開始日
))
```

#### 空白防止
- デフォルト世代を必ず用意
- 世代切り替え時は必ず次世代を作成

## ⚠️ よくある間違い

### 1. 安易な履歴テーブル
```
❌ 間違い：
商品
商品履歴  // 何のため？どう使う？

✅ 正しい：
要件を明確にしてパターン選択
```

### 2. 更新による世代管理
```
❌ 間違い：
UPDATE 価格 SET 適用終了日 = NOW()
INSERT INTO 価格 ...

✅ 正しい：
トランザクションで原子性保証
または追記のみの設計
```

### 3. パフォーマンス考慮不足
```
❌ 間違い：
すべての世代を同一テーブル
→ データ量増大で劣化

✅ 正しい：
- アーカイブ戦略
- パーティショニング
- 適切なインデックス
```

## 🔍 チェックリスト

世代管理を設計する際の確認事項：

- [ ] 本当に世代管理が必要か再確認した
- [ ] 過去データの参照頻度を確認した
- [ ] 未来データの扱いを確認した
- [ ] 適切なパターンを選択した
- [ ] 世代の切り替え方法を決めた
- [ ] 重複・空白の対策を検討した
- [ ] パフォーマンスを考慮した
- [ ] アーカイブ戦略を検討した
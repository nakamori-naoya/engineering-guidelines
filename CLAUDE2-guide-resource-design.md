# リソース設計の手引き

## 🤔 AIが理解に困る典型的な状況

### 1. 隠れたイベントの発見

#### 更新日時のサイン
リソースに以下の属性を持たせたくなったら要注意：

- 更新日時
- 変更日時
- 最終更新日
- 更新者ID
- 変更回数

#### 隠れたイベントの抽出手順

**Step 1: 更新理由を列挙**
```
例：顧客エンティティの更新理由
- 住所変更
- 電話番号変更
- ステータス変更
- 担当者変更
```

**Step 2: それぞれをイベント化**
```
顧客 (R) {
  顧客ID
  顧客名
  // 更新日時は持たない
}

住所変更 (E) {
  変更ID
  顧客ID
  新住所
  変更日時
  変更理由
}

ステータス変更 (E) {
  変更ID
  顧客ID
  新ステータス
  変更日時
  承認者ID
}
```

### 2. 区分・種別の扱い

#### サブタイプが必要なサイン
- 区分により必須属性が異なる
- 区分により業務ルールが異なる
- 区分により関連するエンティティが異なる

#### サブタイプ設計の例

**例：従業員の区分**
```
従業員 (R) {
  従業員ID
  氏名
  従業員区分
}

正社員 (R) {
  従業員ID
  基本給
  賞与率
}

契約社員 (R) {
  従業員ID
  時給
  契約期間
}

パート (R) {
  従業員ID
  時給
  勤務可能曜日
}
```

### 3. ライフサイクルの考慮

#### 典型的なライフサイクル
1. **生成** - 最初のデータ作成
2. **変更** - 属性の更新
3. **無効化** - 論理削除
4. **削除** - 物理削除（稀）

#### ライフサイクルイベントの設計
```
商品 (R) {
  商品ID
  商品名
  // 削除フラグは持たない
}

商品登録 (E) {
  登録ID
  商品ID
  登録日時
  登録者ID
}

商品廃番 (E) {
  廃番ID
  商品ID
  廃番日時
  廃番理由
}
```

## 💡 設計のコツ

### リソースの識別子設計

#### 自然キー vs 代理キー
```
// 自然キー
従業員 (R) {
  従業員番号  // 業務で使われる番号
  氏名
}

// 代理キー
従業員 (R) {
  従業員ID  // システムが生成
  従業員番号
  氏名
}
```

選択基準：
- 変更可能性があるなら代理キー
- 業務で不変なら自然キー可

### 状態管理の方法

#### 方法1: 最新状態のみ
```
在庫 (R) {
  商品ID
  現在庫数  // 常に最新
}
```

#### 方法2: イベントから導出
```
在庫 (R) {
  商品ID
  // 在庫数は持たない
}

入庫 (E) {
  入庫ID
  商品ID
  入庫数
  入庫日時
}

出庫 (E) {
  出庫ID
  商品ID
  出庫数
  出庫日時
}
// 現在庫 = Σ入庫 - Σ出庫
```

### コード・マスタの扱い

#### 変更頻度による判断
```
// 変更が稀 → リソース
都道府県 (R) {
  都道府県コード
  都道府県名
}

// 変更が頻繁 → 世代管理検討
商品カテゴリ (R) {
  カテゴリID
  カテゴリ名
}
```

## ⚠️ よくある間違い

### 1. 安易な削除フラグ
```
❌ 間違い：
顧客 (R) {
  顧客ID
  削除フラグ  // なぜ削除？いつ？誰が？
}

✅ 正しい：
顧客退会 (E) {
  退会ID
  顧客ID
  退会日時
  退会理由
}
```

### 2. 履歴テーブルという名前
```
❌ 間違い：
顧客履歴 {
  // リソースなのかイベントなのか不明
}

✅ 正しい：
顧客属性変更 (E) {
  // 明確にイベント
}
```

### 3. 複合的な状態
```
❌ 間違い：
商品 (R) {
  販売可能フラグ
  在庫有フラグ
  廃番フラグ
  // 組み合わせが複雑
}

✅ 正しい：
商品ステータスを体系化
または個別のイベントで管理
```

## 🔍 チェックリスト

リソース設計で確認すること：

- [ ] 更新日時を持たせようとしていないか
- [ ] 削除フラグを安易に使っていないか
- [ ] 隠れたイベントを全て抽出したか
- [ ] 区分による違いをサブタイプで表現したか
- [ ] ライフサイクルを考慮したか
- [ ] 識別子の設計方針を決めたか
- [ ] 履歴管理の必要性を検討したか
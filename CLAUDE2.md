# ABAnalytics イミュータブルデータモデル設計ガイドライン

本ドキュメントは、ABAnalyticsプロジェクトにおけるイミュータブルデータモデルの設計指針を定めたものである。

## 🎯 設計の基本原則

### 核心思想
**UPDATE（更新）がシステムを最も複雑化する** - この認識から出発し、データの不変性を最大限追求する。

### 設計の3つの柱
1. **事実の不変性** - 発生したイベントは変更不可とする
2. **単一責任** - 1エンティティは1概念のみを表現する
3. **複雑さの可視化** - 隠れた複雑さを明示的に表現する

## 📊 エンティティ設計指針

### 1. エンティティの抽出
5W1Hを用いてエンティティ候補を識別する。
- Who, What, When, Where は主にリソース
- Why, How は主にイベント

### 2. リソースとイベントの分類
エンティティは必ずリソース（R）またはイベント（E）に分類する。

**分類基準**
- 業務活動を記録する日時属性を持つ → イベント
- それ以外 → リソース

**検証方法**
- エンティティ名に「〜する」を付加して自然か確認する

### 3. イベントエンティティの原則

#### 日時属性の単一性
イベントエンティティは必ず1つの日時属性のみを持つ。
複数の日時を持つ場合は、別々のイベントエンティティに分解する。

#### ロングタームイベントパターン
始まりと終わりを持つ長期イベントには以下のパターンを適用する：
- 親イベント：現在ステータスのみ更新可
- 子イベント（詳細アクティビティ）：INSERT ONLYで各段階を記録

### 4. リソースの設計原則

#### 隠れたイベントの抽出
リソースに更新日時を持たせたくなった場合、その更新を引き起こすイベントを必ず抽出する。

#### 区分による扱いの違い
区分や種別により業務上の扱いが異なる場合、サブタイプとして明示的に表現する。

### 5. リレーションシップの設計

#### 非依存リレーションシップ
リソース間・イベント間の非依存な関係は、交差エンティティとして独立させる。
- 外部キーのNULLを回避
- 時系列の逆転を防止

## 🔄 世代管理の設計パターン

リソースの履歴・世代管理が必要な場合、以下のパターンから選択する：

### 基本パターン
1. **シングル世代テーブルパターン**
   - 適用開始日・終了日による管理
   - 全クエリにBETWEEN条件が必要

2. **有効世代ビューパターン**
   - マテリアライズドビューで最新世代を提供
   - 開発負荷を軽減

3. **世代バージョンタグ付けパターン**
   - Gitのようなバージョン管理
   - 過去・未来の世代を統一的に扱う

### 継承パターン（区分管理）
1. **シングルテーブル継承**
   - 区分横断検索が多く、属性差異が少ない場合に適用

2. **具象テーブル継承**
   - 横断検索がほとんどなく、属性差異が大きい場合に適用

3. **クラステーブル継承**
   - 横断検索があり、属性差異も大きい場合に適用

## 🔍 エンティティの3大要素

設計時に必ず以下を明確に定義する：

### 単一性 (Oneness)
何を1つとして扱うかを明確に定義する。

### 同一性 (Sameness)
2つのものが同じとみなされる条件を明確に定義する。

### カテゴリ (Category)
それが何であり、どの分類に属するかを明確に定義する。

## ⚡ 実装制約

### イベントエンティティ
- INSERT ONLYとする
- UPDATE/DELETEは禁止する
- イミュータブルな実装を保証する

### リソースエンティティ
- 最新状態のみ管理する場合はUPDATE可
- 履歴管理が必要な場合は適切な世代パターンを適用する

## 🚫 アンチパターン

以下の設計は避ける：
- 全エンティティへの一律「登録日時」「更新日時」付与
- 安易な「削除フラグ」の使用
- マスタ/トランザクションという曖昧な分類
- 複数概念が混在したエンティティ

## 🔄 設計プロセス

1. **要求分析** - 5W1Hによるエンティティ候補の抽出
2. **分類** - リソース/イベントへの分類
3. **詳細化** - 隠れたイベントの抽出、3大要素の検討
4. **検証** - 更新発生箇所の最小化を確認
5. **実装設計** - 適切なパターンの選択

---

## 📝 適用例

### イベントエンティティの分解例
```
// 悪い例：複数の日時属性
処理 {
  処理ID
  開始日時
  終了日時  // 更新が必要
  承認日時  // 更新が必要
}

// 良い例：個別のイベントに分解
処理開始 (E) {
  開始ID
  処理ID
  開始日時
}

処理終了 (E) {
  終了ID
  処理ID
  終了日時
}

処理承認 (E) {
  承認ID
  処理ID
  承認日時
  承認者ID
}
```

### 隠れたイベントの抽出例
```
// 悪い例：更新日時を持つリソース
設定 (R) {
  設定ID
  設定値
  更新日時  // 隠れたイベントのサイン
}

// 良い例：変更イベントを抽出
設定 (R) {
  設定ID
  設定値
}

設定変更 (E) {
  変更ID
  設定ID
  変更後値
  変更日時
  変更者ID
  変更理由
}
```

---

本ガイドラインに従うことで、変更に強く、業務の本質的な複雑さが可視化されたデータモデルを実現する。
# イベント設計の手引き

## 🤔 AIが理解に困る典型的な状況

### 1. 複数の日時属性をどう分解するか

#### 分解の基本原則
「1イベント = 1日時」の鉄則を守るための分解パターン

**例: 申請プロセス**
```
❌ 間違った設計：
申請 {
  申請ID
  申請日時
  審査開始日時
  審査完了日時
  承認日時
  却下日時
}

✅ 正しい設計：
申請 (E) {
  申請ID
  申請者ID
  申請日時
}

審査開始 (E) {
  審査開始ID
  申請ID
  審査者ID
  審査開始日時
}

審査完了 (E) {
  審査完了ID
  申請ID
  審査結果
  審査完了日時
}

承認 (E) {
  承認ID
  申請ID
  承認者ID
  承認日時
}

却下 (E) {
  却下ID
  申請ID
  却下理由
  却下日時
}
```

### 2. ロングタームイベントの識別

#### 判断基準
- 開始と終了がある
- 途中で状態遷移がある
- 全体の進捗を追跡する必要がある

#### 設計パターン
```
親イベント（ステータス管理）
└─ 子イベント1（INSERT ONLY）
└─ 子イベント2（INSERT ONLY）
└─ 子イベント3（INSERT ONLY）
```

**例: 契約プロセス**
```
契約プロセス (E) {
  プロセスID
  顧客ID
  現在ステータス  // ここだけ更新可
  開始日時
}

契約アクティビティ (E) {
  アクティビティID
  プロセスID
  アクティビティ日時
}
├─ 見積提示 (E)
├─ 契約締結 (E)
├─ 契約変更 (E)
└─ 契約終了 (E)
```

### 3. イベントの粒度の決定

#### 細かすぎる粒度の問題
```
❌ 過度に細分化：
ボタンクリック (E)
マウス移動 (E)
キー入力 (E)
```

#### 粗すぎる粒度の問題
```
❌ 複数の業務が混在：
販売処理 (E) {
  受注も出荷も請求も含む
}
```

#### 適切な粒度の見つけ方
1. **業務の単位で考える** - 1つの業務アクション = 1イベント
2. **記録の必要性で判断** - ビジネス価値があるか
3. **独立性で判断** - 他のイベントと独立して発生するか

## 💡 設計のコツ

### イベントの命名規則
1. **動詞的な名前** を使う
   - ✅ 注文、出荷、支払
   - ❌ 注文データ、出荷情報

2. **過去形も検討** する
   - 注文済み、出荷済み（状態ではなく発生した事実として）

3. **業務用語を優先** する
   - システム用語より業務で使われる言葉

### 属性設計のポイント

#### 必須属性
- イベントID（主キー）
- 発生日時（たった1つ）
- 誰が/何が（主体）

#### よくある属性
- 対象（誰に/何に）
- 理由（なぜ）
- 方法（どのように）
- 金額（いくらで）

### キャンセル・訂正の扱い

#### キャンセルパターン
```
注文 (E) {
  注文ID
  注文日時
  金額
}

注文キャンセル (E) {
  キャンセルID
  注文ID
  キャンセル日時
  キャンセル理由
}
```

#### 訂正パターン
```
価格設定 (E) {
  設定ID
  商品ID
  価格
  設定日時
}

価格訂正 (E) {
  訂正ID
  元設定ID
  訂正後価格
  訂正日時
  訂正理由
}
```

## ⚠️ よくある間違い

### 1. 状態をイベントと混同
```
❌ 間違い：
注文済み (E) {
  現在の状態を表している
}

✅ 正しい：
注文 (E) {
  注文が発生した事実
}
```

### 2. 更新前提の設計
```
❌ 間違い：
処理 (E) {
  処理ID
  ステータス  // 更新される
  最終更新日時  // 更新される
}
```

### 3. イベントの削除
```
❌ 間違い：
「間違って記録したイベントをDELETE」

✅ 正しい：
取消イベントを新規作成
```

## 🔍 チェックリスト

イベント設計で確認すること：

- [ ] 1つの日時属性のみか
- [ ] INSERT ONLYで実現可能か
- [ ] 業務の1アクションを表しているか
- [ ] キャンセル・訂正も別イベントにしたか
- [ ] 適切な粒度になっているか
- [ ] ロングタームイベントを検討したか
- [ ] 6W2Hの必要な要素を属性に含めたか